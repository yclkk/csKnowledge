Java程序的跨平台特性主要是指字节码文件可以在任何具有Java虚拟机的计算机或者电子设备上运行

新生代

stop the world

OopMap

GI ZGC Shenandoah

黑色对象 白色对象 写屏障

![image-20211017012839501](C:\Users\Ki\AppData\Roaming\Typora\typora-user-images\image-20211017012839501.png)

![image-20211017015151602](C:\Users\Ki\AppData\Roaming\Typora\typora-user-images\image-20211017015151602.png)

##### 1.  JVM是什么，有什么特点？

​	jvm是jre的一部分，它是一个虚构的计算机，是通过在实际的计算机上仿真模仿各种计算机功能来实现的

#####  2. JRE\JDK\JVM是什么？ 

​	jdk是java development kit 是支持java程序开发的最小环境

​	jre是java runtime environment 是java类库的java se api子集和java虚拟机 这两部分的统称。是java程序运行的标准环境

​	jvm

##### 3. Java运行时数据区域分别有哪些，分别详细说说有什么作用？

![image-20211011004428207](C:\Users\Ki\AppData\Roaming\Typora\typora-user-images\image-20211011004428207.png)

​	**方法区**：与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、**即时编译器**编译后的代码缓存等数据

​	**堆**：java堆是垃圾收集器管理的内存区域，也称为GC堆（Garbage Collected Heap) 。存放对象和数组

​	**虚拟机栈**：也是线程私有的，生命周期与线程相同。虚拟机栈描述的java线程的内存模型：每个方法被执行的时候，java虚拟机都会同步创建一个栈帧（stack frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程

​		在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError一场；如果java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常

​	**本地方法栈**：虚拟机使用到的本地方法服务

​	**程序计数器**：是一个比较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器；在任何一个确定的时刻，一个处理器都指挥执行一条线程中的指令。因此，为了线程切换后能够恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有"的内存

内存空间小，线程私有。字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成

##### 4. Java对象的创建过程，java对象头，对象访问类型都介绍一下？

 	1.  首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。
 	
 	2.    在类加载检查通过后，接下来虚拟机将为新生对象分配内存。
 	3.   除如何划分可用空间之外，对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。
 	4.   内存分配完成之后，虚拟机必须将分配到的内存空间都（但不包括对象头）都初始化为零值。
 	5.   Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希码、对象的GC**分代年龄**等信息
 	6.   以上工作在虚拟机的视角中，一个新的对象已经产生。

​		在HotSpot虚拟机里，对象在堆内存中存储布局可以划分为三个部分：对象头（Header），实例数据（Instance Data）和对齐填充（Padding）

##### 5. OOM是什么？什么时候会发生OOM？

##### 6. 判断对象存活的算法介绍一下？

 1. **引用计数算法**（Reference Counting）：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；**当引用失效时**，计数器值就减1；任何时刻计数器为零的对象就是不能再被使用的。

    但是单纯引用计数就很解决对象之间的相互 循环引用的问题。

 2. **可达性分析算法**（Reachabaility Analysis）：通过一系列称为“GC Roots的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径被称为”引用链“（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。

    关联区域也应该加入到GC Roots的集合中区

 3. 

##### 7. GC Root是什么？

​	GC Root是一个根对象，作为起始节点集，从这些节点开始向下搜索，搜索过程走过的路径称为“引用链”

##### 8. 哪些可以作为GC Root？

- 虚拟机栈引用的对象
- 方法区中类静态属性引用的对象
- 方法区常量引用的对象，譬如String Table
- 本地方法栈中Native方法引用的对象
- JVM内部的引用，如Class对象
- 同步锁持有的对象。

##### 9. Java引用类型以及各自的应用场景？

引用：

  - 强引用：类似“Object obj = new Object()" 只要引用关系还在，GC永远不会回收
  - 软引用：有用但是非必须的对象，第二次进行回收，如果内存不够才抛出内存溢出一场
  - 弱引用：非必须对象，第二次回收清除
  - 虚引用：PhantomReference(幽灵引用) 不对对象生命周期造成印象，跟踪对象，目的是为了这个对象在回收时得到一个系统通知。

##### 10.垃圾收集算法有哪些？经典的垃圾收集器（7种）都分别介绍一下？

​	两大类：引用计数式垃圾收集（Reference Counting GC 直接收集）、追踪式垃圾收集（Tracing GC间接收集）

	1. 标记-清除算法：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未标记的对象。
	2. 标记-复制算法：它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
	3. 标记-整理：标记过程和标记-清楚算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界意外的内存。



垃圾收集器

![image-20211013174943641](C:\Users\Ki\AppData\Roaming\Typora\typora-user-images\image-20211013174943641.png)

![image-20211017015811218](C:\Users\Ki\AppData\Roaming\Typora\typora-user-images\image-20211017015811218.png)

G1：

新生代：

- Serial： 单线程，
- ParNew ：Serial的多线程并行版本
- Parallel Scavenge：标记-复制算法，追求高吞吐量
- ![image-20211019191459674](C:\Users\Ki\AppData\Roaming\Typora\typora-user-images\image-20211019191459674.png)

老年代：

- CMS（Concurrent mark Sweep）：最短停顿时间
- - 初始标记
  - 并发标记
  - 重新标记
  - 并发清除
- Serial Old
- Parallel Old
