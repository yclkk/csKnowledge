## 一、基础

### 1.1 元字符

> 正则功能：**校验**数据的有效性、**查找符合要求的文本**以及对文本进行**切割和替换**等操作。

#### 元字符的定义

所谓元字符就是指那些在正则表达式中具有特殊意义的专用字符，正则表达式就是由一系列的元字符组成

> 比如`\d`（表示 0-9 这 10 个数字中的任意一个）、`\d{11}`（表示单个数字出现 11 次），其中`\d`和`{11}`就表示元字符。`.`表示匹配除换行符\n以外的任意字符

------

#### 元字符分类

<img src='../src/regular/first_fisrt_sortCharacters.webp' style="zoom:45%;">

1. **特殊单字符**

<img src="../src/regular/first_first_singleCharacter.webp" style="zoom:35%;">

2. **空白符**

不同的系统在每行文本结束位置默认的“换行”会有区别。比如在 Windows 里是 \r\n，在 Linux 和 MacOS 中是 \n。



在正则中，也是类似于 \n 或 \r 等方式来表示空白符号，只要记住它们就行了。平时使用正则，大部分场景使用 \s 就可以满足需求，\s 代表任意单个空白符号。

<img src="../src/regular/first_first_blankCharacter.webp" style="zoom:30%;">

3. **量词**

   比如，在文本中“颜色”这个单词，可能是带有 u 的 colour，也可能是不带 u 的 color，我们使用 colou?r 就可以表示两种情况了

   <img src="../src/regular/first_first_quantifyCharacter.webp" style="zoom:25%;">

4. **范围**

   <img src="../src/regular/first_first_scopeCharacter.webp" style="zoom:25%;">

   匹配http https ftp

   <img src="../src/regular/first_first_scope1Character.webp" style="zoom:45%;">

5. **练习手机号的匹配规则**

   1. 第 1 位固定为数字 1

   2. 第 2 位可能是 3，4，5，6，7，8，9

   3. 第 3 位到第 11 位我们认为可能是 0-9 任意数字。

      通过规则可以得出正则表达式是：`1[3-9 ]\d{9}`

----

### 1.2 量词与贪婪 

#### 贪婪匹配（Greedy）

定义：尽可能最大长度去匹配

<img src="../src/regular/first_second_greedy.webp" style="zoom:40%;">

使用 Python 示例如下，我们可以看到输出结果，也是得到了 4 个匹配结果：a* 在匹配开头的 a 时，会尝试尽量匹配更多的 a，直到第一个字母 b 不满足要求为止，匹配上三个 a，后面每次匹配时都得到了空字符串。

```python
>>> import re
>>> re.findall(r'a*', 'aaabb')
['aaa', '', '', '']
```

----

#### 非贪婪匹配（lazy）

定义：非贪婪模式会尽可能短地去匹配

<img src="../src/regular/first_second_lazy.webp" style="zoom:40%;">

这次匹配到的结果都是单个的 a，非贪婪模式会尽可能短地去匹配。其中*?表示满足条件的情况只匹配一次

```python
>>> import re
>>> re.findall(r'a*', 'aaabb') 
# 贪婪模式
['aaa', '', '', '']
>>> re.findall(r'a*?', 'aaabb')
# 非贪婪模式
['', 'a', '', 'a', '', 'a', '', '', '']
```

<img src="../src/regular/first_second_greedyAndLazy.webp" style="zoom:25%;">

----

#### 独占模式（Possessive）

> 不管是贪婪模式，还是非贪婪模式，都需要发生回溯才能完成相应的功能。但是在一些场景下，我们不需要回溯，匹配不上返回失败就好了，因此正则中还有另外一种模式，独占模式，它类似贪婪匹配，但匹配过程不会发生回溯，因此在一些场合下性能会更好

**回溯例子：**

​	有一正则表达式：`regex = “xy{1,3}z”`

​	匹配的文本：`text = “xyyz”`

​	在匹配时，y{1,3}会尽可能长地去匹配，当匹配完 xyy 后，由于 y 要尽可能匹配最长，即三个，但字符串中后面是个 z 就会导致匹配不上，这时候正则就会==向前回溯==，吐出当前字符 z，接着用正则中的 z 去匹配。



如果把`regex = “xy{1,3}z”`改成`regex = “xy{1,3}?z”`

​	由于 y{1,3}? 代表匹配 1 到 3 个 y，尽可能少地匹配。匹配上一个 y 之后，也就是在匹配上 text 中的 xy 后，正则会使用 z 和 text 中的 xy 后面的 y 比较，发现正则 z 和 y 不匹配，这时正则就会==向前回溯==，重新查看 y 匹配两个的情况，匹配上正则中的 xyy，然后再用 z 去匹配 text 中的 z，匹配成功。



如何变成独占模式：独占模式会尽可能多地去匹配，如果匹配失败就结束，不会进行回溯（独占模式不回溯这个说法其实不够准确，可以理解成“独占模式不会交还已经匹配上的字符”，这样应该就能理解了），这样的话就比较节省时间。==具体的方法就是在量词后面加上加号（+）==

​	`regex = “xy{1,3}+yz”`，此时并不会去匹配z，



如果只是判断文本是否符合规则，则可以使用独占模式; 如果需要获取匹配的结果，则根据需要使用贪婪或非贪婪。

-----

#### 作业

有一篇英文文章，里面有很多单词，单词和单词之间是用空格隔开的，在引号里面的一到多个单词表示特殊含义，即引号里面的多个单词要看成一个单词。现在你需要提取出文章中所有的单词。我们可以假设文章中除了引号没有其它的标点符号，有什么方法可以解决这个问题呢？如果用正则来解决，你能不能写出一个正则，提取出文章中所有的单词呢（不要求结果去重）？

> we found "the little cat" is in the hat, we like "the little cat"
>
> 其中 the little cat 需要看成一个单词

答案：`\w+|"[^"]+"`

----

### 1.3 分组与引用

假设我们现在要去查找 15 位或 18 位数字。根据前面学习的知识，使用量词可以表示出现次数，使用管道符号可以表示多个选择，你应该很快就能写出\d{15}|\d{18}。但经过测试，你会发现，这个正则并不能很好地完成任务，因为 18 位数字也会匹配上前 15 位，具体如下图所示。

<img src="../src/regular/first_third_part.webp" style="zoom:45%;">

如果将\d{15}和\d{18}调换位置之后才发现是符合要求的

> 大多数正则实现中，多分支选择都是左边的优先原则

例子

>  可以使用 “北京市|北京” 来查找 “北京” 和 “北京市”，也可以使用“北京市?”



回到15位和18位的问题上，也可以看成是15位+是否有后3位：\d{15}\d{3}?	 

示例一：\d{15}\d{3}?  由于 \d{3} 表示三次，加问号非贪婪还是 3 次。表示的是\d{3}尽可能少的匹配，那结果还是会匹配到3位

示例二：\d{15}(\d{3})?  在 \d{3} 整体后加问号，表示后面三位有或无，此实例符合结果

#### 分组与编号

>括号在正则中的功能就是用于分组。简单来理解就是，由多个元字符组成某个部分，应该被看成一个整体的时候，可以用括号括起来表示一个整体，这是括号的一个重要功能。其实用括号括起来还有另外一个作用，那就是“复用”

**编号：**第几个括号就是第几个分组

<img src="../src/regular/first_third_id.webp" style="zoom:55%;">

##### 不保存自组

在括号里面的会保存成子组，但有些情况下，你可能只想用括号将某些部分看成一个整体，后续不用再用它，类似这种情况，在实际使用时，是没必要保存子组的。这时我们可以在括号里面使用 `?: `不保存子组。

如果正则中出现了括号，那么我们就认为，这个子表达式在后续可能会再次被引用，所以不保存子组可以提高正则的性能。除此之外呢，这么做还有一些好处，由于子组变少了，正则性能会更好，在子组计数时也更不容易出错

<img src="../src/regular/first_third_nopart.webp" style="zoom:35%;">

##### 括号嵌套

确定分组方式

<img src="../src/regular/first_third_partBracket.webp" style="zoom:50%;">

##### 命名分组

>  分组编号，但由于编号得数在第几个位置，后续如果发现正则有问题，改动了括号的个数，还可能导致编号发生变化，因此一些编程语言提供了命名分组（named grouping），这样和数字相比更容易辨识，不容易出错。命名分组的格式为(?P<分组名>正则)。

示例：Django 的路由中，命名分组示例如下

```python
url(r'^profile/(?P<username>\w+)/$', view_func)
```

在这个示例中，可以使用分组名称 ，不使用编号。但实际上，编号是已经确定好的，也可以使用编号。

==注意：==命名分组并不是所有语言都支持的，在使用时，你需要查阅所用语言正则说明文档，如果支持，**那你才可以使用**

***

#### 分组引用

使用 “反斜扛 + 编号”，即 `\number `的方式来进行引用，而 JavaScript 中是通过$编号来引用，如\$1

<img src="../src/regular/first_third_partQuote.webp" style="zoom:90%;">

----

#### 分组引用在查找中使用

`(\W+)`会匹配所有的单词，所有的单词的分组编号都是1。

`(\W+) \1`：当`(\W+)`为cat时，`\1`也应该为cat，即`cat cat`才能被匹配上

<img src="../src/regular/first_third_partQuoteInstance.webp" style="zoom:50%;">

----

#### 分组查找替换中的使用

和查找类似，我们可以使用反向引用，在得到的结果中，去拼出来我们想要的结果。还是使用刚刚日期时间的例子，我们可以很方便地将它替换成， 2020 年 05 月 10 日这样的格式。

<img src="../src/regular/first_third_partSupersedeInstance.webp" style="zoom:50%;">

